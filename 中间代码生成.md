# 中间代码生成

对应文件：`CodeGen`

## 中间代码生成的任务

将通过词法、语法、语义分析后的结果转换成中间代码，将前端与后端分离，使得后端可以处理多种目标平台。常用中间代码的形式有：波兰式、三地址码、DAG图等。

## 具体代码解释

### 定义操作名称

| 操作名 | 操作含义                         |
| ------ | -------------------------------- |
| ADD    | 加法                             |
| SUB    | 减法                             |
| NEG    | 将操作数按位取反加一（求相反数） |
| EQ     | 等于                             |
| GT     | 大于                             |
| LT     | 小于                             |
| AND    | 与运算                           |
| OR     | 或运算                           |
| NOT    | 将操作数按位取反                 |



### write 函数

用于翻译语法树中的一个节点。该函数首先将节点对应的符号表信息插入符号表中，然后调用 `translate` 函数翻译当前节点，接着递归地调用 `write` 函数翻译当前节点的所有子节点。



### translate函数

用于翻译语法树节点的具体操作。该函数根据节点类型的不同，调用不同的翻译函数来完成对应的操作。具体的解释如下：

- `switch (t->nodeKind) { ... }`：根据当前节点的类型，执行对应的操作。
- `case Parser::CLASS_K: { ... }`：如果当前节点是 `CLASS_K` 类型，表示当前节点为类定义，根据当前类名创建输出文件，并将输出流 `fout` 关联到该文件上。
- `case Parser::SUBROUTINE_DEC_K: { ... }`：如果当前节点是 `SUBROUTINE_DEC_K` 类型，表示当前节点为子程序定义，生成函数或方法的开始标记，并将局部变量的数量传递给 `writeFunction` 函数。。
- `case Parser::ASSIGN_K: { ... }`：如果当前节点是 `ASSIGN_K` 类型，表示当前节点为赋值语句，生成将右侧表达式的值存储到左侧变量中的虚拟机代码。。
- `case Parser::CALL_STATEMENT_K: { ... }`：如果当前节点是 `CALL_STATEMENT_K` 类型，表示当前节点为函数调用语句，生成相应的虚拟机代码来执行函数调用，并将函数返回值弹出栈顶。
- `case Parser::RETURN_STATEMENT_K: { ... }`：如果当前节点是 `RETURN_STATEMENT_K` 类型，表示当前节点为返回语句，生成相应的虚拟机代码来执行返回操作。
- `case Parser::WHILE_STATEMENT_K: { ... }`：如果当前节点是 `WHILE_STATEMENT_K` 类型，表示当前节点为 while 循环语句，生成相应的虚拟机代码来实现 while 循环。
- `case Parser::IF_STATEMENT_K: { ... }`：如果当前节点是 `IF_STATEMENT_K` 类型，表示当前节点为 if 条件语句，这里根据条件和分支生成对应的 if 分支代码。
- `default: /*fallthrough*/;`：如果当前节点类型不是上述任何一种类型，表示当前节点为未知类型，直接跳过。



### translateCall函数

是编译器生成虚拟机代码的部分，通过后序遍历语法树来生成相应的虚拟机代码，包括算术操作、比较操作、布尔操作、函数调用、变量访问等。

具体的解释如下：

- 对于每个节点，首先对它的所有子节点进行后序遍历，即先遍历左子树，再遍历右子树，最后访问根节点。
- 对于不同类型的节点，生成相应的虚拟机代码。具体而言：
  - 对于算术操作节点，根据操作符生成相应的算术指令。如果是加法、减法，则调用 `writeArithmetic(ADD)` 或 `writeArithmetic(SUB)`；如果是乘法、除法，则调用相应的函数 `writeCall("Math.multiply", 2)` 或 `writeCall("Math.divide", 2)`。
  - 对于比较操作节点，根据操作符生成相应的比较指令。如果是大于、小于、等于、小于等于、大于等于、不等于，则调用相应的函数 `writeArithmetic(GT)`、`writeArithmetic(LT)`、`writeArithmetic(EQ)`、`writeArithmetic(GT)`、`writeArithmetic(LT)`、`writeArithmetic(NOT)`。
  - 对于布尔操作节点，根据操作符生成相应的布尔指令。如果是逻辑与、逻辑或、逻辑非，则调用相应的函数 `writeArithmetic(AND)`、`writeArithmetic(OR)`、`writeArithmetic(NOT)`。
  - 对于整数常量节点，调用 `writePush(CONST, value)` 函数将该值压入栈中。
  - 对于取反节点，调用 `writeArithmetic(NEG)` 函数将栈顶元素取反。
  - 对于函数调用节点，调用 `translateCall` 函数生成相应的虚拟机代码。
  - 对于变量节点，根据变量的作用域和类型，调用相应的函数 `writePush` 将该变量的值压入栈中。
  - 对于数组节点，将数组基地址压入栈中，将数组下标压入栈中，调用 `writeArithmetic(ADD)` 将它们相加，并调用 `writePop(POINTER, 1)` 将该地址存储到 `that` 段中，再调用 `writePush(THAT, 0)` 将该地址对应的数组元素压入栈中。
  - 对于布尔常量节点，将 `0` 压入栈中，如果是 `true` 则调用 `writeArithmetic(NOT)` 取反。
  - 对于 `this` 节点，将 `this` 段的地址压入栈中。
  - 对于 `null` 节点，将 `0` 压入栈中。
  - 对于字符串常量节点，调用 `writeCall("String.new", 1)` 函数创建一个新的字符串对象，然后依次调用 `writeCall("String.appendChar", 2)` 函数将每个字符添加到字符串对象中。



### writePush函数

这段代码是编译器生成虚拟机代码的部分，具体而言，它生成将指定段的指定索引处的值压入栈中的虚拟机代码。

具体的解释如下：

- 接受两个参数：`segment` 表示要访问的段，`index` 表示要访问的索引。
- 根据 `segment` 的值生成相应的指令，将该段索引为 `index` 的值压入栈中。具体而言：
  - 如果 `segment` 是 `CONST`，则调用 `fout << "push constant " << index << "\n"` 将常量 `index` 压入栈中。
  - 如果 `segment` 是 `ARG`，则调用 `fout << "push argument " << index << "\n"` 将当前函数的第 `index` 个参数压入栈中。
  - 如果 `segment` 是 `LOCAL`，则调用 `fout << "push local " << index << "\n"` 将当前函数的第 `index` 个局部变量压入栈中。
  - 如果 `segment` 是 `STATIC`，则调用 `fout << "push static " << index << "\n"` 将静态变量表中索引为 `index` 的变量的值压入栈中。
  - 如果 `segment` 是 `THIS`，则调用 `fout << "push this " << index << "\n"` 将当前对象的第 `index` 个字段压入栈中。
  - 如果 `segment` 是 `THAT`，则调用 `fout << "push that " << index << "\n"` 将目标对象的第 `index` 个字段压入栈中。
  - 如果 `segment` 是 `POINTER`，则调用 `fout << "push pointer " << index << "\n"` 将指向 `this` 或 `that` 的指针压入栈中。当 `index` 为 `0` 时，指向 `this`，当 `index` 为 `1` 时，指向 `that`。
  - 如果 `segment` 是 `TEMP`，则调用 `fout << "push temp " << index << "\n"` 将临时变量表中索引为 `index` 的变量压入栈中。

### writePop函数

这段代码是编译器生成虚拟机代码的部分，具体而言，它生成将栈顶元素弹出并存储到指定段的指定索引处的虚拟机代码。

具体的解释如下：

- 接受两个参数：`segment` 表示要访问的段，`index` 表示要访问的索引。
- 根据 `segment` 的值生成相应的指令，将栈顶元素弹出并存储到该段索引为 `index` 的位置中。具体而言：
  - 如果 `segment` 是 `ARG`，则调用 `fout << "pop argument " << index << "\n"` 将栈顶元素存储到当前函数的第 `index` 个参数中。
  - 如果 `segment` 是 `LOCAL`，则调用 `fout << "pop local " << index << "\n"` 将栈顶元素存储到当前函数的第 `index` 个局部变量中。
  - 如果 `segment` 是 `STATIC`，则调用 `fout << "pop static " << index << "\n"` 将栈顶元素存储到静态变量表中索引为 `index` 的变量中。
  - 如果 `segment` 是 `THIS`，则调用 `fout << "pop this " << index << "\n"` 将栈顶元素存储到当前对象的第 `index` 个字段中。
  - 如果 `segment` 是 `THAT`，则调用 `fout << "pop that " << index << "\n"` 将栈顶元素存储到目标对象的第 `index` 个字段中。
  - 如果 `segment` 是 `POINTER`，则调用 `fout << "pop pointer " << index << "\n"` 将栈顶元素存储到指向 `this` 或 `that` 的指针中。当 `index` 为 `0` 时，指向 `this`，当 `index` 为 `1` 时，指向 `that`。
  - 如果 `segment` 是 `TEMP`，则调用 `fout << "pop temp " << index << "\n"` 将栈顶元素存储到临时变量表中索引为 `index` 的变量中。
  - 如果 `segment` 是 `CONST`，则调用 `fout << "pop constant " << index << "\n"` 无效，因为常量是不能被修改的。



### writeArithmetic函数

这段代码是编译器生成虚拟机代码的部分，具体而言，它生成执行算术操作的虚拟机代码。

具体的解释如下：

- 接受一个参数：`command` 表示要执行的算术操作。
- 根据 `command` 的值生成相应的指令，执行相应的算术操作。具体而言：
  - 如果 `command` 是 `ADD`，则调用 `fout << "add\n"` 执行将栈顶两个元素相加的操作。
  - 如果 `command` 是 `SUB`，则调用 `fout << "sub\n"` 执行将栈顶两个元素相减的操作。
  - 如果 `command` 是 `NEG`，则调用 `fout << "neg\n"` 执行将栈顶元素取负的操作。
  - 如果 `command` 是 `EQ`，则调用 `fout << "eq\n"` 执行将栈顶两个元素相等性比较的操作，如果相等，则将结果压入栈中，否则将 0 压入栈中。
  - 如果 `command` 是 `GT`，则调用 `fout << "gt\n"` 执行将栈顶两个元素大小比较的操作，如果第二个元素大于第一个元素，则将结果压入栈中，否则将 0 压入栈中。
  - 如果 `command` 是 `LT`，则调用 `fout << "lt\n"` 执行将栈顶两个元素大小比较的操作，如果第二个元素小于第一个元素，则将结果压入栈中，否则将 0 压入栈中。
  - 如果 `command` 是 `AND`，则调用 `fout << "and\n"` 执行将栈顶两个元素进行逻辑与操作的操作。
  - 如果 `command` 是 `OR`，则调用 `fout << "or\n"` 执行将栈顶



### writeLabel函数

这段代码是编译器生成虚拟机代码的部分，具体而言，它生成设置标签的虚拟机代码。

具体的解释如下：

- 接受一个参数：`label` 表示标签的名称。
- 调用 `fout << "label " << label << "\n"` 生成相应的指令，设置一条虚拟机代码，将 `label` 作为标签名称，并将其写入输出文件中。这条虚拟机代码用于将控制流转移到指定标签处。



### writeGoto函数

这段代码是编译器生成虚拟机代码的部分，具体而言，它生成无条件跳转的虚拟机代码。

具体的解释如下：

- 接受一个参数：`label` 表示跳转到的标签的名称。
- 调用 `fout << "goto " << label << "\n"` 生成相应的指令，设置一条虚拟机代码，将控制流转移到标签为 `label` 的位置，并将其写入输出文件中。这条虚拟机代码用于无条件地将控制流转移到指定标签处。



### writeIf函数

这段代码是编译器生成虚拟机代码的部分，具体而言，它生成条件跳转的虚拟机代码。

具体的解释如下：

- 接受一个参数：`label` 表示跳转到的标签的名称。
- 调用 `fout << "if-goto " << label << "\n"` 生成相应的指令，设置一条虚拟机代码，如果栈顶元素为非零，则将控制流转移到标签为 `label` 的位置，并将其写入输出文件中。这条虚拟机代码用于有条件地将控制流转移到指定标签处。



### writeCall函数

这段代码是编译器生成虚拟机代码的部分，具体而言，它生成调用函数的虚拟机代码。

具体的解释如下：

- 接受两个参数：`name` 表示要调用的函数名称，`nArgs` 表示函数调用时传递给函数的参数个数。
- 调用 `fout << "call " << name << " " << nArgs << "\n"` 生成相应的指令，设置一条虚拟机代码，用于调用名称为 `name` 的函数，并将 `nArgs` 个参数传递给该函数。该虚拟机代码会将当前函数的返回地址和调用该函数时的上下文信息压入栈中，并将控制流转移到被调用函数的入口点处。



### writeFunction函数

这段代码是编译器生成虚拟机代码的部分，具体而言，它生成定义函数的虚拟机代码。

具体的解释如下：

- 接受两个参数：`name` 表示要定义的函数名称，`nArgs` 表示函数调用时传递给函数的参数个数。

- 调用 `fout << "function " << name << " " << nArgs << "\n"` 生成相应的指令，设置一条虚拟机代码，用于定义名称为 `name`、参数个数为 `nArgs` 的函数。该虚拟机代码会为该函数创建一个新的局部变量表，大小为 `nArgs`，并将控制流转移到该函数的入口点处。

  

### writeReturn函数

这段代码是编译器生成虚拟机代码的部分，具体而言，它生成返回函数的虚拟机代码。

具体的解释如下：

- 调用 `fout << "return\n"` 生成相应的指令，设置一条虚拟机代码，用于返回当前函数的控制流和返回值。该虚拟机代码会将当前函数的返回值存储到调用该函数之前的栈帧中，并将控制流转移到调用该函数的位置。